import tkinter as tk
from tkinter import ttk
import json
from datetime import datetime

# Global list to store the transactions
transactions = {}
filename = "json-file.json"

# File handling functions
def load_transactions(filename):
    try:
        with open(filename, 'r') as file:
            transactions = json.load(file)
        return transactions
    except FileNotFoundError:
        print(f"File '{filename}' not found. Please check the file path.")
        return {}
    except json.decoder.JSONDecodeError:
        print(f"Invalid JSON format in file '{filename}'.")
        return {}
    
def save_transactions():
    global transactions
    # Saving transactions to JSON file in write mode 
    with open("json-file.json", "w") as json_file:
        json.dump(transactions, json_file, indent=4)

    # Saving transactions to text file in write mode
    with open("bulk_transactions.txt", "w") as txt_file:
        for category, transaction_dictionary in transactions.items():
            for transaction in transaction_dictionary:# writing transactions in text file as a dictionary
                txt_file.write(f"{category}, {transaction['amount']}, {transaction['type']}, {transaction['date']}\n")

                
def read_bulk_transactions_from_file(filename):
    global transactions
    try:
        with open(filename, 'r') as file:
            for line in file: # reads text file line by line and split the lines using a comma
                lines = line.strip().split(',')
                if len(lines) != 4:# checking whether the length of transaction is 4 or not
                    print("Invalid format for transaction: ", line.strip())
                    continue
                category = lines[0].strip()
                amount = float(lines[1].strip()) # using strip function to remove spaces and converting amount to a float value
                transaction_type = lines[2].strip().lower()# using strip function to remove spaces and only enter the transaction type in lower alphabet
                date_str = lines[3].strip()

                if transaction_type not in ['income', 'expense']:#checking whether the transaction in the correct format as in lower alphabet
                    print("Invalid transaction type for transaction: ", line.strip())
                    continue
                try:
                    date = datetime.strptime(date_str, '%Y-%m-%d').date()# correctly assigning the date format to present the date correctly without generating error
                except ValueError:
                    print("Invalid date format for transaction: ", line.strip())
                    continue
                if category not in transactions:
                    transactions[category] = []
                # inserting transactions to the dictionary belonging to the category
                transactions[category].append({"amount": amount, "type": transaction_type, "date": str(date)})
    except FileNotFoundError: # applying an error hangling method to suffix if any error was generated when opening the file
        print("File not found error!!!")
        
# Feature implementations
def add_transaction():
    global transactions
    category = None  # Initialize category variable
    while True:
        category = input("Enter the category: ")
        # ensuring that category does not contain any digit values by using isdigit function
        if category and not category.isdigit():
            break
        print("Invalid category. Please try again.")

    amount = None  # Initialize amount variable
    while True:
        amount_str = input("Enter the amount: ")
        # placing an error handler when entering the amount incase of and error generated by the user
        try:
            amount = float(amount_str)
            break
        except ValueError:
            print("Invalid value. Please enter a valid number.")

    transaction_type = None  # Initialize transaction_type variable
    while True:
        transaction_type = input("Enter the transaction type (income/expense): ")
        # checking the transaction type is netered in a lower alphabet format
        if transaction_type.lower() in ['income', 'expense']:
            break
        print("Invalid transaction type. Please enter 'income' or 'expense'.")

    date = None  # Initialize date variable
    while True:
        date_str = input("Enter the date (YYYY-MM-DD): ")
        # ensuring that date is entered according to the correct format
        try:
            date = datetime.strptime(date_str, '%Y-%m-%d').date()
            break
        except ValueError: # entering value error method for error ehandling if any occured
            print("Invalid date format. Please try again.")

    if category not in transactions:
        transactions[category] = []

    # inserting transactions to the dictionary belonging to the category
    transactions[category].append({"amount": amount, "type": transaction_type, "date": str(date)})
    save_transactions()
    print("Transactions added successfully.")

# Viewing the transactions
def view_transactions():
    global transactions
    print("View transactions")  # Add this line for debugging
    if not transactions:
        print("No transactions found.")
        return
    choice = input("Enter 'view' to view the file: ").lower()
    if choice == 'view':
        root = tk.Tk()
        app = FinanceTrackerGUI(root)
        root.mainloop()

class FinanceTrackerGUI:
    # commencing self as class for financial tracker gui
    def __init__(self, root):
        self.root = root
        self.root.title("Personal Finance Tracker")
        self.root.geometry('1000x500')#applying a geometrical approach for the gui size
        self.create_widgets()
        self.transactions = self.load_transactions("json-file.json")
        self.filtered_transactions = self.transactions
        self.display_transactions(self.transactions)


    def create_widgets(self):
        # Applyin a Frame for the table 
        self.frame = ttk.Frame(self.root, borderwidth=2, relief=tk.RAISED)
        #the frame is set to held on the left side of the gui output
        self.frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        

        # Creating a Treeview for displaying transactions in an organized data structure
        self.tree = ttk.Treeview(self.frame, columns=("Category", "Amount", "Type", "Date"), show="headings")
        #Creating headings for the treeview with the sorting column command being called
        self.tree.heading("Category", text="Category", command=lambda: self.sort_by_column("Category"))
        self.tree.heading("Amount", text="Amount", command=lambda: self.sort_by_column("Amount"))
        self.tree.heading("Type", text="Type", command=lambda: self.sort_by_column("Type"))
        self.tree.heading("Date", text="Date", command=lambda: self.sort_by_column("Date"))
        # Displaying treeview in the left side of the GUI
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Applying a Scrollbar for the Treeview
        #creating the scrollbar within the the frame vertically
        self.scrollbar = ttk.Scrollbar(self.frame, orient=tk.VERTICAL, command=self.tree.yview)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)#scrollbar on the right side of frame along with the y axis
        self.tree.configure(yscrollcommand=self.scrollbar.set)

        # Search bar and button
        self.search_var = tk.StringVar()
        #Creating a entry for the search where the user can enter values/string
        self.search_entry = ttk.Entry(self.root, text=self.search_var)
        self.search_entry.pack(pady=20)#displaying the search entry
        #Creating a search button for the search entry to function
        self.search_button = ttk.Button(self.root, text="Search", command=self.search_transactions)
        self.search_button.pack()#displaying the search button

        #Reset button to go back to the main menu after a search
        self.reset_button = ttk.Button(self.root, text="Back", command=self.reset_transactions)
        self.reset_button.pack(pady=10)

    def load_transactions(self, filename):
        try:
            with open(filename, 'r') as file:
                return json.load(file)#Loading the json file as read mode 
        except FileNotFoundError:
            return {}#error handling 
        except json.decoder.JSONDecodeError:
            return {}# json error handling

    def display_transactions(self, transactions):
        # Remove existing entries
        for item_id in self.tree.get_children():
            self.tree.delete(item_id)#deleting existing transactions 

        # Add transactions to the treeview
        for category, items in transactions.items():
            for item in items:#adding new transactions to the gui using insert function
                self.tree.insert('', 'end', values=(category, item["amount"], item["type"], item["date"]))

    def search_transactions(self):
        search = self.search_var.get().lower()
        filtered_transactions = {}#considering transactions are within a dictionary
        for category, items in self.transactions.items():
            filtered_items = []#considering transactions are within a list
            for item in items:# user can search using category name or with the values of its items
                if search in str(item) or search in category:
                    filtered_items.append(item)#adding the transactions after entering search
            if filtered_items:
                filtered_transactions[category] = filtered_items
                    
        self.filtered_transactions = filtered_transactions 
        self.display_transactions(self.filtered_transactions)#displaying the filtered transactions

    def reset_transactions(self):
        if self.search_var.get().strip():# Checking if the search bar is not empty
            self.search_var.set("")# Clearing the search entry after transaction is searcheed
            self.search_transactions()
        else:
            self.display_transactions(self.transactions)

        
    def sort_by_column(self, col, reverse=False):
        #using child-parent function to set the transactions
        transactions = [(self.tree.set(child, col), child) for child in self.tree.get_children("")]
        # Checking if all the values are numeric
        if all(value.replace('.', '', 1).isdigit() for value, _ in transactions):  
            transactions.sort(key=lambda x: float(x[0]), reverse=reverse)
        else:
            transactions.sort(key=lambda x: x[0].lower(), reverse=reverse)
        
        # Rearranging items in the treeview based on the sorted data using child-parent function
        for index, (value, child) in enumerate(transactions):# iterating over the transactions 
            self.tree.move(child, "", index)
        
        # Updatingthe heading command to toggle sorting
        self.tree.heading(col, command=lambda: self.sort_by_column(col, not reverse))

# Updating the transactions
def update_transaction():
    global transactions
    print("transactions recorded")  # Add this line for debugging
    if not transactions:
        print("No transactions found.")
        return
    for category, items in transactions.items():
        print(f"Category: {category}")
        for item in items:
            print(f"Amount: {item['amount']}, Type: {item['type']}, Date: {item['date']}\n")
        

    # Getting the user to input the updating category
    category_to_update = input("Enter the category to update transaction: ")

    if category_to_update in transactions:
        category_transactions = transactions[category_to_update]

        # Display transactions in the chosen category by the user
        for index, transaction in enumerate(category_transactions):
            print(f"{index + 1}. Amount: {transaction['amount']}, type: {transaction['type']}, Date: {transaction['date']}")
        # asking the user the index of the necessary transaction to be updated
        while True:
            try:
                index = int(input("Enter the index of the transaction to update: ")) - 1
                if 0 <= index < len(category_transactions):
                    break
                else:
                    print("Invalid index. Please enter a valid index.")
            except ValueError: # incas of an error being occured
                print("Invalid input. Please enter a valid number.")

        # Getting the new transaction details from the user for updation
        amount = float(input("Enter new amount: "))

        while True:
            # checking the transaction type is netered in a lower alphabet format
            transaction_type = input("Enter the transaction type (income/expense): ")
            if transaction_type.lower() in ['income', 'expense']:
                break
            print("Invalid transaction type. Please enter 'income' or 'expense'.")

        # Handle date consistently as string
        while True:
            new_date_str = input("Enter new date (YYYY-MM-DD): ")
            try:
                # parsing the new data entered according to the date time format
                datetime.strptime(new_date_str, '%Y-%m-%d')
                break  # Exiting the loop if the date string is valid
            except ValueError:# and if date time is invalid it will conclude an error
                print("Invalid date format. Please enter the date in the format YYYY-MM-DD.")

        # Updating the transaction details with the new details entered by the user
        category_transactions[index]['amount'] = amount
        category_transactions[index]['type'] = transaction_type
        category_transactions[index]['date'] = new_date_str  

        # Saving the updated transactions in the file created
        save_transactions()
        print("Transaction updated successfully!")

    else:
        print("Category not found.")

# Deleting the transaction
def delete_transaction():
    global transactions
    print("transactions recorded")  # Add this line for debugging
    if not transactions:
        print("No transactions found.")
        return
    for category, items in transactions.items():
        print(f"Category: {category}")
        for item in items:
            print(f"Amount: {item['amount']}, Type: {item['type']}, Date: {item['date']}\n")

    category_delete = input("Enter the category to delete the transaction: ")

    # Checking if the category that the user entered exists
    if category_delete in transactions:
        category_transactions = transactions[category_delete]

        # Displaying the transactions in the chosen category
        for index, transaction in enumerate(category_transactions):# using an in-built function to iterate over a sequence
            print(f"{index + 1}. Amount: {transaction['amount']}, type: {transaction['type']}, Date: {transaction['date']}")
            
        while True:
            try:
                index = int(input("Enter the index of the transaction to delete: ")) - 1
                if 0 <= index < len(category_transactions):
                    break
                else:
                    print("Invalid index. Please enter a valid index.")
            except ValueError:
                print("Invalid input. Please enter a valid number.")

        # Deleting transaction from the chosen category
        del category_transactions[index]

        # Checking if there are any transactions left in the category
        if not category_transactions:
            del transactions[category_delete]

        save_transactions()
        print("Transaction deleted successfully!")

    else:
        print("Category not found.")

# Displaying the summary
def display_summary():
    global transactions
    if not transactions:# If no transactions are to be found it will generate as 'no transactions found'.
        print("No transactions found.")
        return
    # intializing total income and expense to zero
    total_income = 0
    total_expenses = 0

    for category, category_transactions in transactions.items():
        for transaction in category_transactions:
            amount = transaction["amount"]
            if transaction["type"] == "income":#if the user enters type as income it will be added to the total income
                total_income += amount
            elif transaction["type"] == "expense":#if the user enters type as expense it will be added to the total expense
                total_expenses += amount
    # Profi or loss will be found by reducing the total income from th total expenses
    profit_or_loss = total_income - total_expenses
    print(f"Total income: {total_income}")
    print(f"Total expenses: {total_expenses}")
    print(f"Profit/Loss: {profit_or_loss}")

def main_menu():
    while True:
        print("\nPersonal Finance Tracker")
        print("1. Add Transaction")
        print("2. View Transactions")
        print("3. Update Transaction")
        print("4. Delete Transaction")
        print("5. Display Summary")
        print("6. Exit")
        choice = input("Enter your choice: ")
        if choice == '1':
            add_transaction()
        elif choice == '2':
            view_transactions()
        elif choice == '3':
            update_transaction()
        elif choice == '4':
            delete_transaction()
        elif choice == '5':
            display_summary()
        elif choice == '6':
            print("Exiting the program.")
            break
        else:
            print("Invalid choice. Please try again.")

def main():
    load_transactions("json-file.json")  
    read_bulk_transactions_from_file("bulk_transactions.txt")
    main_menu()

if __name__ == "__main__":
    main()
